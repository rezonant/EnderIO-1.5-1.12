buildscript {
    repositories {
        jcenter()
        mavenCentral()
        maven { url = 'https://maven.minecraftforge.net' }
        maven { url = 'https://maven.parchmentmc.org' }
        maven { url = 'https://plugins.gradle.org/m2/' }
    }

    dependencies {
        classpath "gradle.plugin.net.intellisun:modDependencies:1.0.1-alpha.2" // https://github.com/IntelliSun-MC/modDependencies
        classpath 'org.junit.platform:junit-platform-gradle-plugin:1.0.3'
        classpath "com.vladsch.flexmark:flexmark:0.34.52"
        classpath "com.vladsch.flexmark:flexmark-pdf-converter:0.34.52"
    }
}

plugins {
    id 'net.minecraftforge.gradle' version '5.1.+'
    id 'org.parchmentmc.librarian.forgegradle' version '1.+'
}

//apply plugin: 'net.minecraftforge.gradle'
//apply plugin: 'org.parchmentmc.librarian.forgegradle'

// We use these to mess with the eclipse .classpath file
//import org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry
//import org.gradle.plugins.ide.eclipse.model.ProjectDependency

// More user properties
ext.user = parseConfig(file('user.properties'))
if (ext.user != null) {
    ext.user.each { k, v ->
        project.ext.set(k, v)
    }
}

def release = System.getenv("RELEASE") != null &&
              !System.getenv("RELEASE").equalsIgnoreCase("false")

// Configure all projects
allprojects {
    apply plugin: 'net.minecraftforge.gradle'
    apply plugin: 'org.parchmentmc.librarian.forgegradle'
    apply plugin: 'net.intellisun.moddependencies'
    apply plugin: 'org.junit.platform.gradle.plugin'

    // Import mod dependencies and execute
    if (file('dependencies.gradle').exists())
        apply from: 'dependencies.gradle'

    group = 'com.enderio'
    version = getVersionString(project)
    archivesBaseName = getArchiveBaseName(project)

    // Configure minecraft pipline
    minecraft {
        mappings channel: mappings_channel, version: mappings_version

        if (file('src/main/resources/META-INF/accesstransformer.cfg').exists())
            accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg')

        // If the module defines `dependencyString` use it
        // TODO
//        if (project.hasProperty('dependencyString'))
//            replace 'DEFAULT_DEPENDENCIES;', "\"${dependencyString}\";"
    }

    // The is very temporary, currently not all modules compile
    // This will exclude all non compiling modules from CI but
    // they will still appear is IDEs.
    // TODO: Remove this once all modules compile
    if (!project.hasProperty('include_in_build'))
         project.ext.include_in_build = true
    else
        project.ext.include_in_build = project.include_in_build != 'false'

    if (!project.hasProperty('include_in_combjar'))
         project.ext.include_in_combjar = true
    else
        project.ext.include_in_combjar = project.include_in_combjar != 'false'

    if (!project.hasProperty('publish_api'))
         project.ext.publish_api = true
    else
        project.ext.publish_api = project.publish_api != 'false'

    project.ext.include_in_combjar = project.ext.include_in_combjar && project.ext.include_in_build

    java.toolchain.languageVersion = JavaLanguageVersion.of(17)

    repositories {
        mavenCentral()
        //maven { url = "https://tehnut.info/maven" }
        maven { url = "https://maven.tterrag.com" }
        //maven { url = "https://maven2.tterrag.com" }
        maven { url = "https://dvs1.progwml6.com/files/maven" }
        maven { url = "https://maven.minecraftforge.net" }
        maven { url = "https://maven.cil.li/" } // OpenComputers
        maven { url = "https://maven.ic2.player.to" }
        maven { url = "https://maven.mcmoddev.com" } // ???, dead as of 2021-01-10, back as of 2021-05-24
        //maven { url = "https://maven.blamejared.com" } // temp replacement for ^
        maven { url = "https://mod-buildcraft.com/maven/" }
        maven { url = "https://maven.covers1624.net/" } // CoFHCore
        maven { url = "https://www.cursemaven.com" } // Mekanism
        //maven { url = "https://repo.raoulvdberge.com/" } // Refined Storage (new)
        //maven { url = "https://repo.refinedmods.com/" } // Refined Storage (double-plus new)
        maven { url = "https://maven.hypherionmc.me/" } // our backups for vanished sources
        maven { url = "https://modmaven.dev/" } // appeng etc. but mostly 1.16 stuff
        maven { url = "https://maven.theillusivec4.top/" } // curios
        maven { url = "https://maven.creeperhost.net" } // refinedstorage
        mavenLocal()
    }
    
    configurations {
        // configuration that holds jars to embed inside the jar
        embed
    }

    junitPlatform {
      platformVersion '1.0.3'
      enableStandardTestTask true
    }

    def localEnderCore = project.hasProperty('use_local_ender_core') && project.getProperty('use_local_ender_core').equalsIgnoreCase('true')

    // Common dependencies for all modules
    dependencies {
        minecraft "net.minecraftforge:forge:${minecraft_version}-${forge_version}"

        // Remote / local endercore
        if (!localEnderCore || gradle.startParameter.taskNames.contains("runClient")) {
            compileOnly fg.deobf("com.enderio.core:EnderCore:${endercore_version}")
        }

        // All jars in the '<module>/lib' directory
        compileOnly fileTree(dir: "lib", include: '*.jar')

        // All jars in the '<root>/lib' directory
        implementation fileTree(dir: "${project.rootDir}/lib", include: '*.jar')

        testImplementation "org.junit.jupiter:junit-jupiter-api:5.2.0"
        testImplementation "org.junit.jupiter:junit-jupiter-api:5.2.0"
        testImplementation "org.junit.platform:junit-platform-launcher:1.1.0"
        testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:5.2.0"

        if (project.name != 'ap') {
            annotationProcessor project(':ap')
            implementation project(':ap')
        }
    }

    // Java 8 throws errors about jdoc, ignore them
    if (JavaVersion.current().isJava8Compatible()) {
        tasks.withType(Javadoc) {
            options.addStringOption('Xdoclint:none', '-quiet')
        }
    }

    // Build the key store for jar signing
    task mkKeyStore(type: Exec) {
       workingDir projectDir
       commandLine 'keytool', '-genkey', '-storetype', 'PKCS12', '-alias', 'signFiles', '-keystore', 'eiostore.jks', '-storepass', '123456', '-noprompt', '-dname', 'CN='+getCN(), '-keypass', '123456'
    }

	// Convert the core recipes to pdf so the users won't have editable recipe files in their
	// config folder. Crude, but it prevents a common mistake. BTW, setting those files to
	// read-only works in theory, but all common launchers fail to handle read-only files
	// correctly.
	processResources.doLast {
		def resdir = new File(project.sourceSets.main.output.resourcesDir, "assets/enderio/config/recipes")
		project.fileTree([dir: resdir, include: '*.xml']).files.each { file ->
			def baseFilename = file.name.take(file.name.lastIndexOf('.'))
			def inputFile  = new File(resdir, "${baseFilename}.xml")
			def outputFile = new File(resdir, "${baseFilename}.pdf")
			com.vladsch.flexmark.pdf.converter.PdfConverterExtension.exportToPdf(outputFile.path,
				"<html><head></head><body><div style='white-space:pre-wrap; font-family:monospace;'>" +
				groovy.xml.XmlUtil.escapeXml(inputFile.text) + 
				"</div></body></html>", "", new com.vladsch.flexmark.util.options.MutableDataSet())
		}
	}

	// this needs to be here for cursegradle.addArtifact to be able to reference it
	task recipeJar(type: Jar, dependsOn: jar) {
	    classifier = 'recipes'
	    extension = 'zip'
	    enabled = rootProject == project
	
	    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
	}
}

// Configuration that applies only to modules
subprojects {

    jar {
        into('/META-INF/libraries') {
            from configurations.embed
        }

        doFirst {
            manifest {
                def contained = configurations.embed.collect { it.getName() };
                if (!contained.isEmpty()) {
                    attributes([
                        "ContainedDeps": contained.join(' ')
                    ])
                }
            }
        }
    }

    // Assembly an API jar
    task apiJar(type: Jar) {
    	enabled = project.ext.publish_api
        classifier = 'api'

        from sourceSets.main.output.classesDirs
        include 'crazypants/enderio/api/**/*.class'
        from sourceSets.main.java
        include 'crazypants/enderio/api/**/*.java'
    }

    // Assemble a source jar
    task sourcesJar(type: Jar) {
    	enabled = false
        classifier = 'sources'
        from sourceSets.main.java
    }
}

// Part of the temporary fix for not compiling modules
def buildprojects = subprojects.findAll { sp -> sp.ext.include_in_build }
def combjarprojects = subprojects.findAll { sp -> sp.ext.include_in_combjar }

// Make sure all modules are configured
buildprojects.each { subproject -> evaluationDependsOn( subproject.path ) }

jar.doFirst {
    // This code merge all resources that are duplicated across the modules.
    // Since modules are shiped both as separate modules and as an 'all' jar
    // some manifest files are duplicated.
    File target = new File(project.sourceSets.main.output.resourcesDir, "assets/enderio/lang")
    target.mkdirs()
    combjarprojects.each { subproject ->
        File langDir = new File(subproject.sourceSets.main.output.resourcesDir, 'assets/enderio/lang/')
        if (langDir.exists()) {
            langDir.eachFileMatch( ~".*\\.lang\$" ) { langfile ->
                new File(target, langfile.name) << langfile.text << "\n"
            }
        }
    }

    def mcmod = ""
    combjarprojects.each { subproject ->
        mcmod += new File(subproject.sourceSets.main.output.resourcesDir, 'mcmod.info').text
    }
    new File(project.sourceSets.main.output.resourcesDir, "mcmod.info") << mcmod.replaceAll(/\]\s*\[/, ',')

    def sound = ""
    combjarprojects.each { subproject ->
        File soundFile = new File(subproject.sourceSets.main.output.resourcesDir, 'assets/enderio/sounds.json')
        if (soundFile.exists()) {
            sound += soundFile.text
        }
    }
    new File(project.sourceSets.main.output.resourcesDir, "assets/enderio/sounds.json") << sound.replaceAll(/\}\s*\{/, ',')

    println "Created derived resources in ${target}"
}

// Collect all sources from the modules and merge them
// into the all jar.
jar.dependsOn combjarprojects.tasks['classes']
jar {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    combjarprojects.each { subproject ->
        from subproject.sourceSets.main.output.classesDirs
        from subproject.sourceSets.main.output.resourcesDir

        into('/META-INF/libraries') {
            from subproject.configurations.embed
        }
    }
    doFirst {
        manifest {
            attributes([
                "ContainedDeps": combjarprojects.collect { it.configurations.embed.collect { it.getName() }}.flatten().join(' ')
            ])
        }
    }
}

task sourceJar(type: Jar) {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    getArchiveClassifier().set('sources')
    combjarprojects.each { subproject ->
        from subproject.sourceSets.main.java
    }
}

// recipeJar real content. must be here so it can use buildprojects
buildprojects.each { subproject ->
    recipeJar.from subproject.sourceSets.main.output.resourcesDir, {
	    include 'assets/enderio/config/recipes/*.xml'
	    include 'assets/enderio/config/recipes/*.xsd'
    }
}

// Copy all the jars to `libs`
task copyJars(type: Copy) {
    from buildprojects.collect { it.tasks.withType(Jar) }
    into "$buildDir/libs"
}

// Combine all the API jars into a single jar
task combApiJar(type: Jar) {
    dependsOn copyJars
    classifier 'api'
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    combjarprojects.each { subproject ->
    	if (subproject.apiJar.enabled)
	   	    from zipTree(subproject.apiJar.getArchivePath()).asFileTree
    }
}

artifacts {
    archives combApiJar
}

build.dependsOn sourceJar, combApiJar, recipeJar

apply plugin: 'maven-publish'

publishing {
    tasks.publish.dependsOn 'build'
    publications {
        mavenJava(MavenPublication) {
            from components.java                                //Define the properties of the publication
            version minecraft_version + "-" + project.version
            artifact sourceJar
            artifact combApiJar
            artifact recipeJar

            pom.withXml { //Here we can add custom nodes to the pom file
                def dependenciesNode = asNode().getAt("dependencies")[0]
                if (dependenciesNode == null) {
                    dependenciesNode = asNode().appendNode('dependencies')
                }

                //Iterate over the compile dependencies (we don't want the test ones), adding a <dependency> node for each
                configurations.compile.allDependencies.each {
                    if (!it.name.equals("unspecified")) { //filter out the garbage
                        def dependencyNode = dependenciesNode.appendNode('dependency')
                        dependencyNode.appendNode('groupId', it.group)
                        dependencyNode.appendNode('artifactId', it.name)
                        dependencyNode.appendNode('version', it.version)
                    }
                }
            }
        }
    }

    repositories {
    	if (project.hasProperty('mavendir')) println "maven_publish: mavendir is set"
    	if (project.hasProperty('maven2_url')) println "maven_publish: maven2_url is set (and ignored)"
    	if (project.hasProperty('maven2_user')) println "maven_publish: maven2_user is set"
    	if (project.hasProperty('maven2_pass')) println "maven_publish: maven2_pass is set"
    	if (System.getenv('MAVEN_GITHUB_USER') != null) println "maven_publish: MAVEN_GITHUB_USER is set"
    	if (System.getenv('MAVEN_GITHUB_TOKEN') != null) println "maven_publish: MAVEN_GITHUB_TOKEN is set"
    	if (release) println "maven_publish: release is set"

        def pub_github = System.getenv('MAVEN_GITHUB_USER') != null && System.getenv('MAVEN_GITHUB_TOKEN') != null
        if (pub_github) {
            maven {
                url uri("https://maven.pkg.github.com/sleepytrousers/enderio")
                credentials {
                    username System.getenv('MAVEN_GITHUB_USER')
                    password System.getenv('MAVEN_GITHUB_TOKEN')
                }
            }
        }
//        def pub_maven = release && (project.hasProperty('mavendir') || project.hasProperty('maven2_url'))
        def pub_maven = release && project.hasProperty('mavendir')
        if (pub_maven) {
//	        if (project.hasProperty('mavendir')) {
	            maven { url mavendir }
//	        } else if (project.hasProperty('maven2_user') && project.hasProperty('maven2_pass')) {
//                maven {
//                    url maven2_url
//                    credentials {
//                        username maven2_user
//                        password maven2_pass
//                    }
//                }
//            } else {
//                maven { url maven2_url }
//            }
        }
        if (!pub_github && !pub_maven) {
            mavenLocal()
        }
    }
}

// Part of the temporary fix for not compiling modules
gradle.taskGraph.whenReady {
    def tasksToDisable = [
        'build', 'compileJava', 'assemble', 'sourceJar',
        'check', 'reobfJar', 'signJar', 'apiJar'
    ]

    gradle.taskGraph.allTasks.each {
        if(!it.project.ext.include_in_build) {
            if (tasksToDisable.find { n -> it.name == n } != null) it.enabled = false
        }
    }
}

// Generate a random cmmon name for the cert
String getCN() {
    def firsts = ['Donald', 'Lex', 'The', 'Arthur', 'Bridget', 'Dorian', 'Ford', 'Guy', 'James', 'Jessica', 'John', 'Michael', 'Robinson', 'Zaphod', 'Bell', 'Penelope']
    def lasts = ['Duck', 'Luthor', 'Doctor', 'Master', 'Dent', 'Jones', 'Gray', 'Prefect', 'Montag', 'Moriarty', 'Rabbit', 'Watson', 'Smith', 'Corleone', 'Crusoe', 'Beeblebrox', 'Cranel', 'Akk']
    def rand = new Random()
    return firsts[rand.nextInt(firsts.size())] + ' ' + lasts[rand.nextInt(lasts.size())]
}

// This is the new version/module format:
// module name:
//   enderio-<name>-<mc-version>-<version>
// version:
//   <major>.<minor>.<patch>-<cls>-<hash>
// patch:
//   defaults to 'version_patch'
//   overriten by CI / build server
// cls (classifier):
//   * nightly
//   * dev
//   * ci
//   * snapshot
//   * etc.
// hash:
//   if on a dev machine - the current commit hash

// Examples:
//   * enderio-base-1.12.2-4.0.1.jar            :: release version 4.0.1 for mc 1.12.2
//   * enderio-base-1.12.2-4.2.1-nightly-4      :: nightly build no. 4 for version 4.2.1
//   * enderio-base-1.12.2-4.5.1-dev-c91c8ee6e  :: dev (local) build for commit c91c8ee6e
String getVersionString(Project proj) {
    def build_server = System.getenv('CI') != null || System.getenv('BUILD_NUMBER') != null

    def version_patch_lc = proj.version_patch
    if (System.getenv('BUILD_NUMBER') != null)
        version_patch_lc = System.getenv('BUILD_NUMBER')

    def version_classifier = ''
    if (System.getenv('VERSION_CLS') != null)
        version_classifier = System.getenv('VERSION_CLS')
    else if (System.getenv('NIGHTLY') != null)
        version_classifier = 'nightly'

    def version_hash = ''
    if (!build_server) {
        try {
            version_hash = "git rev-parse --short HEAD".execute().text.trim()
        } catch (all) { }
    }

    def version_base = "${proj.version_major}.${proj.version_minor}.${version_patch_lc}"
    def version_parts = ([ version_base, version_classifier, version_hash ]).findAll { p -> p != '' }

    return String.join('-', version_parts)
}

String getPrettyName(Project proj) {
    def project_base_name = rootProject.name
    if (proj.hasProperty('module_name'))
        project_base_name += "-${proj.module_name}"
    return project_base_name
}

String getArchiveBaseName(Project proj) {
    return getPrettyName(proj) + "-${project.minecraft_version}"
}

String getChangelogFormat() {
    return new File(projectDir, 'doc/changelog.html').getText('UTF-8')
}

// parse and import external config
def parseConfig(File config) {
    if (!config.exists())
        return null

    config.withReader {
        def prop = new Properties()
        prop.load(it)
        return (new ConfigSlurper().parse(prop))
    }
}

def resolveOption(Project project, String option, boolean defaultValue = false) {
    def sourceValue = project.hasProperty(option) ? project.property(option) : defaultValue

    return sourceValue == 'true' || sourceValue == true || sourceValue == 1
}
